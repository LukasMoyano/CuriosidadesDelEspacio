// src/index.ts
import path from "path";

// src/transform.ts
import { init, parse as parseImport } from "es-module-lexer";
import { Parser as Parser2 } from "acorn";
import MagicString from "magic-string";

// src/format.ts
import _ from "lodash";
var kebabCase = _.kebabCase;
function formatedComponentName(libraryName, componentName, option) {
  const {
    libraryDirectory = "lib",
    camel2DashComponentName = true,
    customName
  } = option;
  let finalComponentPath = "";
  const formated = camel2DashComponentName ? kebabCase(componentName) : componentName;
  if (customName && typeof customName === "function") {
    finalComponentPath = customName(formated);
    if (!finalComponentPath) {
      return "";
    }
  } else {
    finalComponentPath = `${libraryName}/${libraryDirectory}/${formated}/index`;
  }
  return finalComponentPath;
}
function formatedStyleName(libraryName, componentName, option) {
  const {
    style,
    libraryDirectory = "lib",
    camel2DashComponentName = true,
    styleLibraryDirectory,
    customStyleName
  } = option;
  let finalCssPath = "";
  if (!style && !styleLibraryDirectory) {
    return "";
  }
  const formated = camel2DashComponentName ? kebabCase(componentName) : componentName;
  if (customStyleName && typeof customStyleName === "function") {
    finalCssPath = customStyleName(formated);
    if (!finalCssPath) {
      return "";
    }
  } else {
    const libPath = `${libraryName}/${(styleLibraryDirectory || libraryDirectory) + "/"}${formated}`;
    let cssPath;
    if (typeof style === "function") {
      cssPath = style(libPath);
      if (!cssPath) {
        return "";
      }
    } else {
      cssPath = style === "css" ? "style/css" : "style";
    }
    finalCssPath = `${libPath}/${cssPath}`;
  }
  return finalCssPath;
}

// src/ast.ts
import { Parser } from "acorn";
function isObjectNode(node) {
  return typeof node === "object" && node !== null;
}
function visitMemberExpression(ast, components, localLibName, option) {
  if (ast.type === "MemberExpression") {
    if (ast.object && ast.object.name === localLibName) {
      components.push({
        start: ast.start,
        end: ast.end,
        componentName: ast.property.name,
        ...option
      });
    }
  }
  const keys = Object.keys(ast);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const child = ast[key];
    if (Array.isArray(child)) {
      for (let j = 0; j < child.length; j++) {
        visitMemberExpression(child[j], components, localLibName, option);
      }
    } else if (isObjectNode(child)) {
      visitMemberExpression(child, components, localLibName, option);
    }
  }
}
function getusedDefaultComponents(code, localLibName, libraryName, option, registryImport) {
  const ast = Parser.parse(code, {
    ecmaVersion: "latest",
    sourceType: "module"
  });
  let components = [];
  let jsxAndTsxComponents = [];
  if (!ast.body || !ast.body.length) {
    return {
      components,
      jsxAndTsxComponents,
      registryImport
    };
  }
  for (const node of ast.body) {
    if (node.type === "VariableDeclaration") {
      let transformExpress = "";
      for (const dec of node.declarations) {
        const decInitType = dec.init.type;
        if (decInitType === "Literal") {
          continue;
        } else if (decInitType === "MemberExpression") {
          if (dec.init.object.name === localLibName) {
            const componentName = dec.id.name;
            const finalComponentPath = formatedComponentName(libraryName, componentName, option);
            const finalCssPath = formatedStyleName(libraryName, componentName, option);
            if (registryImport.has(componentName)) {
              continue;
            }
            registryImport.add(componentName);
            if (!!finalCssPath) {
              transformExpress += `import ${componentName} from "${finalComponentPath}"; 
import "${finalCssPath}"; 
`;
            } else {
              transformExpress += `import ${componentName} from "${finalComponentPath}"; 
`;
            }
          }
        } else if (decInitType === "Identifier" && dec.id.type === "ObjectPattern") {
          for (const prop of dec.id.properties) {
            const finalComponentPath = formatedComponentName(libraryName, prop.key.name, option);
            const finalCssPath = formatedStyleName(libraryName, prop.key.name, option);
            const componentName = prop.value.name;
            if (registryImport.has(componentName)) {
              continue;
            }
            registryImport.add(componentName);
            if (!!finalCssPath) {
              transformExpress += `import ${componentName} from "${finalComponentPath}"; 
import "${finalCssPath}"; 
`;
            } else {
              transformExpress += `import ${componentName} from "${finalComponentPath}"; 
`;
            }
          }
        }
      }
      if (transformExpress) {
        components.push({
          transformExpress,
          start: node.start,
          end: node.end
        });
      }
    } else {
      visitMemberExpression(node, jsxAndTsxComponents, localLibName, option);
    }
  }
  return {
    components,
    jsxAndTsxComponents,
    registryImport
  };
}

// src/transform.ts
var transformCode = async (code, importOptions) => {
  let s;
  await init;
  const [imports] = parseImport(code);
  s = new MagicString(code);
  imports.forEach(({
    d: dynamic,
    n: dependence,
    ss: statementStart,
    se: statementEnd
  }) => {
    var _a, _b;
    if (dynamic !== -1) {
      return;
    }
    const raw = code.substring(statementStart, statementEnd);
    const ast = Parser2.parse(raw, {
      ecmaVersion: "latest",
      sourceType: "module"
    });
    const specifiers = (_a = ast.body[0]) == null ? void 0 : _a.specifiers;
    const source = (_b = ast.body[0]) == null ? void 0 : _b.source;
    if (!specifiers) {
      return;
    }
    const libraryName = source.value;
    const option = importOptions.find(
      (importOption) => importOption.libraryName === libraryName
    );
    if (!option) {
      return;
    }
    const importSpecifierComponent = (specifier) => {
      const { imported, local } = specifier;
      const componentName = imported.name;
      const finalComponentPath = formatedComponentName(libraryName, componentName, option);
      const finalCssPath = formatedStyleName(libraryName, componentName, option);
      if (!!finalCssPath) {
        return `import ${local.name} from "${finalComponentPath}";
import "${finalCssPath}"; 
`;
      } else {
        return `import ${local.name} from "${finalComponentPath}";
`;
      }
    };
    let usedDefaultComponents = [];
    let usedJsxComponents = [];
    let registryImport = /* @__PURE__ */ new Set();
    const newImportStr = specifiers.reduce((s2, specifier) => {
      if (specifier.type === "ImportDefaultSpecifier") {
        const localLibName = specifier.local.name;
        const {
          components,
          jsxAndTsxComponents,
          registryImport: defaultRegistryImport
        } = getusedDefaultComponents(code, localLibName, libraryName, option, registryImport);
        usedDefaultComponents = components;
        usedJsxComponents = jsxAndTsxComponents;
        registryImport = defaultRegistryImport;
      } else if (specifier.type === "ImportSpecifier") {
        s2 += importSpecifierComponent(specifier);
      }
      return s2;
    }, "");
    if (!newImportStr) {
      const isQuoteAfter = s.slice(statementEnd, statementEnd + 1) === ";";
      const stateEnd = isQuoteAfter ? statementEnd + 1 : statementEnd;
      s.remove(statementStart, stateEnd);
    } else {
      s.overwrite(statementStart, statementEnd + 1, newImportStr);
    }
    for (const component of usedDefaultComponents) {
      const { transformExpress, start, end } = component;
      s.overwrite(start, end, transformExpress);
    }
    let jsxNewImport = "";
    for (const jsxComponent of usedJsxComponents) {
      const { componentName, start, end, libraryName: libraryName2 } = jsxComponent;
      s.overwrite(start, end, componentName);
      const jsxCssPath = formatedStyleName(libraryName2, componentName, option);
      let newImportExpression = "";
      if (!!jsxCssPath) {
        newImportExpression = `import ${componentName} from "${formatedComponentName(libraryName2, componentName, option)}";
import "${jsxCssPath}";
`;
      } else {
        newImportExpression = `import ${componentName} from "${formatedComponentName(libraryName2, componentName, option)}";
`;
      }
      if (!registryImport.has(componentName)) {
        registryImport.add(componentName);
        jsxNewImport += newImportExpression;
      }
    }
    if (jsxNewImport) {
      s.overwrite(statementStart, statementEnd, jsxNewImport);
    }
  });
  if (!s) {
    return code;
  }
  return s.toString();
};
var transform_default = transformCode;

// src/index.ts
function dynamicImportPlugin(options) {
  return {
    name: "vite-plugin-importus",
    async transform(code, id) {
      let importOptions = [];
      if (Array.isArray(options)) {
        importOptions = options;
      } else {
        throw new Error("Options must be array.");
      }
      const ext = path.extname(id).slice(1);
      if (["js", "jsx", "ts", "tsx"].indexOf(ext) > -1) {
        code = await transform_default(code, importOptions);
      }
      return code;
    }
  };
}
export {
  dynamicImportPlugin as default
};
